#!/usr/bin/env python3
"""
Create GitHub Issue for CVEs detected by Trivy.

Parses Trivy JSON output and creates a formatted GitHub issue with
CVE details, affected packages, and remediation guidance.

Usage:
    python create-cve-issue.py --trivy-report results.json --service arc-sherlock-brain
    python create-cve-issue.py --trivy-report results.json --service arc-sherlock-brain --dry-run

Environment Variables:
    GITHUB_TOKEN: GitHub token for creating issues
    GITHUB_REPOSITORY: Repository in owner/repo format
"""
import argparse
import json
import logging
import os
import sys
from dataclasses import dataclass
from typing import Optional

logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)


@dataclass
class Vulnerability:
    """Represents a CVE vulnerability."""
    cve_id: str
    severity: str
    package: str
    installed_version: str
    fixed_version: Optional[str]
    title: str
    description: str
    cvss_score: Optional[float] = None
    references: list = None

    def __post_init__(self):
        if self.references is None:
            self.references = []


def parse_trivy_report(report_path: str) -> list[Vulnerability]:
    """Parse Trivy JSON report and extract vulnerabilities."""
    with open(report_path) as f:
        data = json.load(f)

    vulnerabilities = []

    for result in data.get('Results', []):
        for vuln in result.get('Vulnerabilities', []):
            v = Vulnerability(
                cve_id=vuln.get('VulnerabilityID', 'Unknown'),
                severity=vuln.get('Severity', 'UNKNOWN'),
                package=vuln.get('PkgName', 'Unknown'),
                installed_version=vuln.get('InstalledVersion', 'Unknown'),
                fixed_version=vuln.get('FixedVersion'),
                title=vuln.get('Title', 'No title'),
                description=vuln.get('Description', 'No description'),
                cvss_score=vuln.get('CVSS', {}).get('nvd', {}).get('V3Score'),
                references=vuln.get('References', [])[:3],  # Limit to 3 refs
            )
            vulnerabilities.append(v)

    return vulnerabilities


def generate_issue_body(
    service: str,
    vulnerabilities: list[Vulnerability],
    image_ref: Optional[str] = None,
    commit_sha: Optional[str] = None,
) -> str:
    """Generate formatted issue body."""
    # Count by severity
    severity_counts = {}
    for v in vulnerabilities:
        severity_counts[v.severity] = severity_counts.get(v.severity, 0) + 1

    # Build body
    lines = [
        '## Security Alert',
        '',
        f'Vulnerabilities detected in `{service}` service.',
        '',
        '### Summary',
        '',
        '| Severity | Count |',
        '|----------|-------|',
    ]

    for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
        count = severity_counts.get(severity, 0)
        if count > 0:
            emoji = {'CRITICAL': 'ðŸ”´', 'HIGH': 'ðŸŸ ', 'MEDIUM': 'ðŸŸ¡', 'LOW': 'ðŸŸ¢'}.get(severity, 'âšª')
            lines.append(f'| {emoji} {severity} | {count} |')

    lines.extend([
        '',
        '### Details',
        '',
    ])

    if image_ref:
        lines.append(f'**Image:** `{image_ref}`')
    if commit_sha:
        lines.append(f'**Commit:** `{commit_sha[:7]}`')

    lines.extend([
        '',
        '### Vulnerabilities',
        '',
    ])

    # Group by severity
    for severity in ['CRITICAL', 'HIGH', 'MEDIUM']:
        severity_vulns = [v for v in vulnerabilities if v.severity == severity]
        if not severity_vulns:
            continue

        lines.append(f'#### {severity} ({len(severity_vulns)})')
        lines.append('')

        for v in severity_vulns[:10]:  # Limit to 10 per severity
            lines.append(f'<details><summary><strong>{v.cve_id}</strong>: {v.package} ({v.installed_version})</summary>')
            lines.append('')
            lines.append(f'**Title:** {v.title}')
            lines.append('')
            lines.append(f'**Description:** {v.description[:500]}...' if len(v.description) > 500 else f'**Description:** {v.description}')
            lines.append('')

            if v.fixed_version:
                lines.append(f'**Fix:** Upgrade to `{v.fixed_version}`')
            else:
                lines.append('**Fix:** No fix available yet')

            if v.cvss_score:
                lines.append(f'**CVSS Score:** {v.cvss_score}')

            if v.references:
                lines.append('')
                lines.append('**References:**')
                for ref in v.references:
                    lines.append(f'- {ref}')

            lines.append('')
            lines.append('</details>')
            lines.append('')

        if len(severity_vulns) > 10:
            lines.append(f'*... and {len(severity_vulns) - 10} more {severity} vulnerabilities*')
            lines.append('')

    # Remediation steps
    lines.extend([
        '### Remediation Steps',
        '',
        '1. Review the vulnerabilities listed above',
        '2. Update affected packages to fixed versions where available',
        '3. For vulnerabilities without fixes, evaluate risk and consider:',
        '   - Alternative packages',
        '   - Workarounds',
        '   - Accepting the risk (document in security policy)',
        '4. Create a PR with the fixes',
        '5. This issue will be automatically closed when CVEs are resolved',
        '',
        '---',
        '',
        '_This issue was automatically created by A.R.C. CI/CD security scanning._',
    ])

    return '\n'.join(lines)


def create_github_issue(
    title: str,
    body: str,
    labels: list[str],
    repo: str,
    token: str,
    dry_run: bool = False,
) -> Optional[str]:
    """Create a GitHub issue."""
    if dry_run:
        logger.info('DRY RUN - Would create issue:')
        logger.info(f'  Title: {title}')
        logger.info(f'  Labels: {labels}')
        logger.info(f'  Body length: {len(body)} chars')
        return None

    try:
        from github import Github

        g = Github(token)
        repo_obj = g.get_repo(repo)

        # Check for existing issue with same CVE in title
        existing = repo_obj.get_issues(state='open', labels=labels)
        for issue in existing:
            if title in issue.title:
                logger.info(f'Issue already exists: #{issue.number}')
                return issue.html_url

        # Create new issue
        issue = repo_obj.create_issue(
            title=title,
            body=body,
            labels=labels,
        )

        logger.info(f'Created issue: {issue.html_url}')
        return issue.html_url

    except ImportError:
        logger.error('PyGithub not installed. Run: pip install PyGithub')
        return None
    except Exception as e:
        logger.error(f'Failed to create issue: {e}')
        return None


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        '--trivy-report',
        type=str,
        required=True,
        help='Path to Trivy JSON report',
    )
    parser.add_argument(
        '--service',
        type=str,
        required=True,
        help='Service name',
    )
    parser.add_argument(
        '--image-ref',
        type=str,
        default=None,
        help='Image reference',
    )
    parser.add_argument(
        '--commit-sha',
        type=str,
        default=os.environ.get('GITHUB_SHA'),
        help='Git commit SHA',
    )
    parser.add_argument(
        '--min-severity',
        choices=['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'],
        default='CRITICAL',
        help='Minimum severity to report',
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Print issue content without creating',
    )

    args = parser.parse_args()

    # Parse Trivy report
    logger.info(f'Parsing Trivy report: {args.trivy_report}')
    vulnerabilities = parse_trivy_report(args.trivy_report)

    # Filter by severity
    severity_order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
    min_index = severity_order.index(args.min_severity)
    included_severities = severity_order[:min_index + 1]

    vulnerabilities = [v for v in vulnerabilities if v.severity in included_severities]

    logger.info(f'Found {len(vulnerabilities)} vulnerabilities at {args.min_severity} or higher')

    if not vulnerabilities:
        logger.info('No vulnerabilities to report')
        return

    # Count critical
    critical_count = sum(1 for v in vulnerabilities if v.severity == 'CRITICAL')
    high_count = sum(1 for v in vulnerabilities if v.severity == 'HIGH')

    # Generate issue
    title = f'Security: {critical_count} CRITICAL, {high_count} HIGH CVEs in {args.service}'
    body = generate_issue_body(
        service=args.service,
        vulnerabilities=vulnerabilities,
        image_ref=args.image_ref,
        commit_sha=args.commit_sha,
    )
    labels = ['security', 'cve', 'automated']

    if critical_count > 0:
        labels.append('critical')

    if args.dry_run:
        print('=' * 60)
        print(f'TITLE: {title}')
        print(f'LABELS: {labels}')
        print('=' * 60)
        print(body)
        print('=' * 60)
    else:
        token = os.environ.get('GITHUB_TOKEN')
        repo = os.environ.get('GITHUB_REPOSITORY')

        if not token or not repo:
            logger.error('GITHUB_TOKEN and GITHUB_REPOSITORY environment variables required')
            sys.exit(1)

        url = create_github_issue(title, body, labels, repo, token)
        if url:
            print(f'Issue URL: {url}')


if __name__ == '__main__':
    main()
