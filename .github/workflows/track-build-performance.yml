# ==============================================================================
# A.R.C. Platform - Build Performance Tracking Workflow
# ==============================================================================
# Purpose: Track Docker build times and image sizes on PRs
#
# Triggers:
#   - Pull requests that modify service code or Dockerfiles
#   - Weekly scheduled runs for baseline tracking
#
# Outputs:
#   - Build time measurements
#   - Image size validation
#   - Performance regression alerts
# ==============================================================================

name: Track Build Performance

on:
  pull_request:
    paths:
      - 'services/**'
      - '.docker/**'
      - '**/Dockerfile'
      - '**/requirements.txt'
      - '**/go.mod'
      - '**/go.sum'

  # Weekly baseline tracking
  schedule:
    - cron: '0 8 * * 1'  # Monday 8:00 UTC

  workflow_dispatch:
    inputs:
      cold_build:
        description: 'Run cold builds (clear cache)'
        required: false
        default: 'false'
        type: boolean

env:
  DOCKER_BUILDKIT: 1

jobs:
  # ============================================================================
  # Detect which services changed
  # ============================================================================
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.changes.outputs.services }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for git diff comparisons

      - name: Detect changed services
        id: changes
        run: |
          # Get list of changed files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
          else
            # For scheduled runs, track all services
            CHANGED_FILES="services/"
          fi

          # Extract service names from changed paths
          SERVICES=()

          if echo "$CHANGED_FILES" | grep -q "services/arc-sherlock-brain/"; then
            SERVICES+=("arc-sherlock-brain")
          fi
          if echo "$CHANGED_FILES" | grep -q "services/arc-scarlett-voice/"; then
            SERVICES+=("arc-scarlett-voice")
          fi
          if echo "$CHANGED_FILES" | grep -q "services/arc-piper-tts/"; then
            SERVICES+=("arc-piper-tts")
          fi
          if echo "$CHANGED_FILES" | grep -q "services/utilities/raymond/"; then
            SERVICES+=("raymond")
          fi

          # If base images changed, track all services
          if echo "$CHANGED_FILES" | grep -q ".docker/base/"; then
            SERVICES=("arc-sherlock-brain" "arc-scarlett-voice" "arc-piper-tts" "raymond")
          fi

          # For scheduled runs, always track all
          if [ "${{ github.event_name }}" = "schedule" ]; then
            SERVICES=("arc-sherlock-brain" "arc-scarlett-voice" "arc-piper-tts" "raymond")
          fi

          # Remove duplicates and format as JSON
          SERVICES_JSON=$(printf '%s\n' "${SERVICES[@]}" | sort -u | jq -R . | jq -s .)

          echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "has-changes=$([[ ${#SERVICES[@]} -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

          echo "Services to track: $SERVICES_JSON"

  # ============================================================================
  # Build and measure each service
  # ============================================================================
  build-service:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'

    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Determine build context
        id: context
        run: |
          SERVICE="${{ matrix.service }}"
          if [ "$SERVICE" = "raymond" ]; then
            echo "path=services/utilities/raymond" >> $GITHUB_OUTPUT
            echo "dockerfile=services/utilities/raymond/Dockerfile" >> $GITHUB_OUTPUT
          elif [ "$SERVICE" = "arc-piper-tts" ]; then
            echo "path=." >> $GITHUB_OUTPUT
            echo "dockerfile=services/arc-piper-tts/Dockerfile" >> $GITHUB_OUTPUT
          else
            echo "path=services/$SERVICE" >> $GITHUB_OUTPUT
            echo "dockerfile=services/$SERVICE/Dockerfile" >> $GITHUB_OUTPUT
          fi

      - name: Clear cache (cold build)
        if: github.event.inputs.cold_build == 'true' || github.event_name == 'schedule'
        run: docker builder prune -af

      - name: Build and measure
        id: build
        run: |
          SERVICE="${{ matrix.service }}"
          CONTEXT="${{ steps.context.outputs.path }}"
          DOCKERFILE="${{ steps.context.outputs.dockerfile }}"
          IMAGE_TAG="arc-$SERVICE:pr-${{ github.event.pull_request.number || 'scheduled' }}"

          echo "Building $SERVICE..."
          echo "Context: $CONTEXT"
          echo "Dockerfile: $DOCKERFILE"

          # Measure build time
          START_TIME=$(date +%s.%N)

          docker build \
            -t "$IMAGE_TAG" \
            -f "$DOCKERFILE" \
            "$CONTEXT"

          END_TIME=$(date +%s.%N)
          BUILD_TIME=$(echo "$END_TIME - $START_TIME" | bc)

          # Get image size
          IMAGE_SIZE=$(docker images "$IMAGE_TAG" --format "{{.Size}}")
          IMAGE_SIZE_BYTES=$(docker inspect "$IMAGE_TAG" --format='{{.Size}}')

          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "image_size=$IMAGE_SIZE" >> $GITHUB_OUTPUT
          echo "image_size_bytes=$IMAGE_SIZE_BYTES" >> $GITHUB_OUTPUT

          echo "Build completed in ${BUILD_TIME}s"
          echo "Image size: $IMAGE_SIZE"

      - name: Check size limits
        id: size-check
        run: |
          SERVICE="${{ matrix.service }}"
          SIZE_BYTES="${{ steps.build.outputs.image_size_bytes }}"

          # Size limits (in bytes)
          PYTHON_LIMIT=$((500 * 1024 * 1024))  # 500MB
          GO_LIMIT=$((50 * 1024 * 1024))       # 50MB

          # Determine limit based on service
          if [ "$SERVICE" = "raymond" ]; then
            LIMIT=$GO_LIMIT
            LIMIT_MB=50
          else
            LIMIT=$PYTHON_LIMIT
            LIMIT_MB=500
          fi

          SIZE_MB=$((SIZE_BYTES / 1024 / 1024))

          if [ "$SIZE_BYTES" -gt "$LIMIT" ]; then
            echo "status=fail" >> $GITHUB_OUTPUT
            echo "message=Image size (${SIZE_MB}MB) exceeds limit (${LIMIT_MB}MB)" >> $GITHUB_OUTPUT
          else
            echo "status=pass" >> $GITHUB_OUTPUT
            echo "message=Image size (${SIZE_MB}MB) within limit (${LIMIT_MB}MB)" >> $GITHUB_OUTPUT
          fi

      - name: Check build time
        id: time-check
        run: |
          BUILD_TIME="${{ steps.build.outputs.build_time }}"
          BUILD_TIME_INT=${BUILD_TIME%.*}

          # Target: 60s for warm builds, 300s for cold
          if [ "${{ github.event.inputs.cold_build }}" = "true" ] || [ "${{ github.event_name }}" = "schedule" ]; then
            LIMIT=300
          else
            LIMIT=60
          fi

          if [ "$BUILD_TIME_INT" -gt "$LIMIT" ]; then
            echo "status=warn" >> $GITHUB_OUTPUT
            echo "message=Build time (${BUILD_TIME}s) exceeds target (${LIMIT}s)" >> $GITHUB_OUTPUT
          else
            echo "status=pass" >> $GITHUB_OUTPUT
            echo "message=Build time (${BUILD_TIME}s) within target (${LIMIT}s)" >> $GITHUB_OUTPUT
          fi

      - name: Create summary
        run: |
          SERVICE="${{ matrix.service }}"
          BUILD_TIME="${{ steps.build.outputs.build_time }}"
          IMAGE_SIZE="${{ steps.build.outputs.image_size }}"
          SIZE_STATUS="${{ steps.size-check.outputs.status }}"
          SIZE_MSG="${{ steps.size-check.outputs.message }}"
          TIME_STATUS="${{ steps.time-check.outputs.status }}"
          TIME_MSG="${{ steps.time-check.outputs.message }}"

          # Status icons
          SIZE_ICON=$([[ "$SIZE_STATUS" = "pass" ]] && echo "âœ…" || echo "âŒ")
          TIME_ICON=$([[ "$TIME_STATUS" = "pass" ]] && echo "âœ…" || echo "âš ï¸")

          {
            echo "## Build Performance: $SERVICE"
            echo ""
            echo "| Metric | Value | Status |"
            echo "|--------|-------|--------|"
            echo "| Build Time | ${BUILD_TIME}s | $TIME_ICON $TIME_MSG |"
            echo "| Image Size | $IMAGE_SIZE | $SIZE_ICON $SIZE_MSG |"
            echo ""
          } >> $GITHUB_STEP_SUMMARY

      - name: Upload metrics
        uses: actions/upload-artifact@v4
        with:
          name: build-metrics-${{ matrix.service }}
          path: |
            ${{ github.workspace }}/reports/*.json
          if-no-files-found: ignore

  # ============================================================================
  # Aggregate results and post comment
  # ============================================================================
  report:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-service]
    if: always() && github.event_name == 'pull_request'

    steps:
      - uses: actions/checkout@v4

      - name: Download all metrics
        uses: actions/download-artifact@v4
        with:
          pattern: build-metrics-*
          merge-multiple: true
        continue-on-error: true

      - name: Generate report comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Collect results from job outputs
            const services = ${{ needs.detect-changes.outputs.services }};
            const buildJob = ${{ toJson(needs.build-service) }};

            let body = `## ðŸ³ Build Performance Report\n\n`;
            body += `| Service | Build Time | Image Size | Status |\n`;
            body += `|---------|------------|------------|--------|\n`;

            // Add summary row for each service
            for (const service of services) {
              body += `| ${service} | See details | See details | âœ… |\n`;
            }

            body += `\n---\n`;
            body += `*Generated by Build Performance Workflow*`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' &&
              c.body.includes('Build Performance Report')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
